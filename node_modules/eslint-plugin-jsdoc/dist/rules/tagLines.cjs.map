{"version":3,"file":"tagLines.cjs","names":["_iterateJsdoc","_interopRequireDefault","require","e","__esModule","default","checkMaxBlockLines","maxBlockLines","startLines","utils","reportJSDoc","description","getDescription","excessBlockLinesRegex","RegExp","excessBlockLinesMatch","match","excessBlockLines","length","excessIndexLine","slice","index","line","setBlockDescription","info","seedTokens","descLines","postDelims","newPostDelims","map","desc","idx","number","source","tokens","postDelimiter","_default","exports","iterateJsdoc","context","jsdoc","alwaysNever","applyToEndTag","count","endLines","startLinesWithNoTags","tags","options","some","tg","tagIdx","lastTag","lastEmpty","reportIndex","emptyLinesCount","end","name","tag","type","entries","includes","lines","empty","lineDiff","fixer","removeTag","tagSourceOffset","addLines","currentTag","tagSourceIdx","splice","push","currentTg","tagCount","defaultAlways","overrideAlways","fixCount","noTags","lastDescriptionLine","test","startingLines","trailingLines","trailingDiff","Array","from","trim","iterateAllJsdocs","meta","docs","url","fixable","schema","enum","additionalProperties","properties","anyOf","patternProperties","module"],"sources":["../../src/rules/tagLines.js"],"sourcesContent":["import iterateJsdoc from '../iterateJsdoc.js';\n\n/**\n * @param {{\n *   maxBlockLines: null|number,\n *   startLines: null|number,\n *   utils: import('../iterateJsdoc.js').Utils\n * }} cfg\n */\nconst checkMaxBlockLines = ({\n  maxBlockLines,\n  startLines,\n  utils,\n}) => {\n  if (typeof maxBlockLines !== 'number') {\n    return false;\n  }\n\n  if (typeof startLines === 'number' && maxBlockLines < startLines) {\n    utils.reportJSDoc(\n      'If set to a number, `maxBlockLines` must be greater than or equal to `startLines`.',\n    );\n    return true;\n  }\n\n  const {\n    description,\n  } = utils.getDescription();\n  const excessBlockLinesRegex = new RegExp('\\n{' + (maxBlockLines + 2) + ',}', 'v');\n  const excessBlockLinesMatch = description.match(excessBlockLinesRegex);\n  const excessBlockLines = excessBlockLinesMatch?.[0]?.length ?? 0;\n  if (excessBlockLinesMatch) {\n    const excessIndexLine = description.slice(0, excessBlockLinesMatch.index).match(/\\n/gv)?.length ?? 0;\n    utils.reportJSDoc(\n      `Expected a maximum of ${maxBlockLines} line${maxBlockLines === 1 ? '' : 's'} within block description`,\n      {\n        line: excessIndexLine,\n      },\n      () => {\n        utils.setBlockDescription((info, seedTokens, descLines, postDelims) => {\n          const newPostDelims = [\n            ...postDelims.slice(0, excessIndexLine),\n            ...postDelims.slice(excessIndexLine + excessBlockLines - 1 - maxBlockLines),\n          ];\n          return [\n            ...descLines.slice(0, excessIndexLine),\n            ...descLines.slice(excessIndexLine + excessBlockLines - 1 - maxBlockLines),\n          ].map((desc, idx) => {\n            return {\n              number: 0,\n              source: '',\n              tokens: seedTokens({\n                ...info,\n                description: desc,\n                postDelimiter: newPostDelims[idx],\n              }),\n            };\n          });\n        });\n      },\n    );\n    return true;\n  }\n\n  return false;\n};\n\nexport default iterateJsdoc(({\n  context,\n  jsdoc,\n  utils,\n}) => {\n  const [\n    alwaysNever = 'never',\n    {\n      applyToEndTag = true,\n      count = 1,\n      endLines = 0,\n      maxBlockLines = null,\n      startLines = 0,\n      startLinesWithNoTags = null,\n      tags = {},\n    } = {},\n  ] = context.options;\n\n  jsdoc.tags.some((tg, tagIdx) => {\n    let lastTag;\n\n    /**\n     * @type {null|import('../iterateJsdoc.js').Integer}\n     */\n    let lastEmpty = null;\n\n    /**\n     * @type {null|import('../iterateJsdoc.js').Integer}\n     */\n    let reportIndex = null;\n    let emptyLinesCount = 0;\n    for (const [\n      idx,\n      {\n        tokens: {\n          description,\n          end,\n          name,\n          tag,\n          type,\n        },\n      },\n    ] of tg.source.entries()) {\n      // May be text after a line break within a tag description\n      if (description) {\n        reportIndex = null;\n      }\n\n      if (lastTag && [\n        'always', 'any',\n      ].includes(tags[lastTag.slice(1)]?.lines)) {\n        continue;\n      }\n\n      const empty = !tag && !name && !type && !description;\n      if (\n        empty && !end &&\n        (alwaysNever === 'never' ||\n          lastTag && tags[lastTag.slice(1)]?.lines === 'never'\n        )\n      ) {\n        reportIndex = idx;\n\n        continue;\n      }\n\n      if (!end) {\n        if (empty) {\n          emptyLinesCount++;\n        } else {\n          emptyLinesCount = 0;\n        }\n\n        lastEmpty = empty ? idx : null;\n      }\n\n      lastTag = tag;\n    }\n\n    if (\n      typeof endLines === 'number' &&\n      lastEmpty !== null && tagIdx === jsdoc.tags.length - 1\n    ) {\n      const lineDiff = endLines - emptyLinesCount;\n\n      if (lineDiff < 0) {\n        const fixer = () => {\n          utils.removeTag(tagIdx, {\n            tagSourceOffset: /** @type {import('../iterateJsdoc.js').Integer} */ (\n              lastEmpty\n            ) + lineDiff + 1,\n          });\n        };\n\n        utils.reportJSDoc(\n          `Expected ${endLines} trailing lines`,\n          {\n            line: tg.source[lastEmpty].number + lineDiff + 1,\n          },\n          fixer,\n        );\n      } else if (lineDiff > 0) {\n        const fixer = () => {\n          utils.addLines(\n            tagIdx,\n            /** @type {import('../iterateJsdoc.js').Integer} */ (lastEmpty),\n            endLines - emptyLinesCount,\n          );\n        };\n\n        utils.reportJSDoc(\n          `Expected ${endLines} trailing lines`,\n          {\n            line: tg.source[lastEmpty].number,\n          },\n          fixer,\n        );\n      }\n\n      return true;\n    }\n\n    if (reportIndex !== null) {\n      const fixer = () => {\n        utils.removeTag(tagIdx, {\n          tagSourceOffset: /** @type {import('../iterateJsdoc.js').Integer} */ (\n            reportIndex\n          ),\n        });\n      };\n\n      utils.reportJSDoc(\n        'Expected no lines between tags',\n        {\n          line: tg.source[0].number + 1,\n        },\n        fixer,\n      );\n\n      return true;\n    }\n\n    return false;\n  });\n\n  (applyToEndTag ? jsdoc.tags : jsdoc.tags.slice(0, -1)).some((tg, tagIdx) => {\n    /**\n     * @type {{\n     *   idx: import('../iterateJsdoc.js').Integer,\n     *   number: import('../iterateJsdoc.js').Integer\n     * }[]}\n     */\n    const lines = [];\n\n    let currentTag;\n    let tagSourceIdx = 0;\n    for (const [\n      idx,\n      {\n        number,\n        tokens: {\n          description,\n          end,\n          name,\n          tag,\n          type,\n        },\n      },\n    ] of tg.source.entries()) {\n      if (description) {\n        lines.splice(0);\n        tagSourceIdx = idx;\n      }\n\n      if (tag) {\n        currentTag = tag;\n      }\n\n      if (!tag && !name && !type && !description && !end) {\n        lines.push({\n          idx,\n          number,\n        });\n      }\n    }\n\n    const currentTg = currentTag && tags[currentTag.slice(1)];\n    const tagCount = currentTg?.count;\n\n    const defaultAlways = alwaysNever === 'always' && currentTg?.lines !== 'never' &&\n      currentTg?.lines !== 'any' && lines.length < count;\n\n    let overrideAlways;\n    let fixCount = count;\n    if (!defaultAlways) {\n      fixCount = typeof tagCount === 'number' ? tagCount : count;\n      overrideAlways = currentTg?.lines === 'always' &&\n        lines.length < fixCount;\n    }\n\n    if (defaultAlways || overrideAlways) {\n      const fixer = () => {\n        utils.addLines(tagIdx, lines[lines.length - 1]?.idx || tagSourceIdx + 1, fixCount - lines.length);\n      };\n\n      const line = lines[lines.length - 1]?.number || tg.source[tagSourceIdx].number;\n      utils.reportJSDoc(\n        `Expected ${fixCount} line${fixCount === 1 ? '' : 's'} between tags but found ${lines.length}`,\n        {\n          line,\n        },\n        fixer,\n      );\n\n      return true;\n    }\n\n    return false;\n  });\n\n  if (checkMaxBlockLines({\n    maxBlockLines,\n    startLines,\n    utils,\n  })) {\n    return;\n  }\n\n  if (typeof startLines === 'number' || typeof startLinesWithNoTags === 'number') {\n    const noTags = !jsdoc.tags.length;\n\n    if (noTags && startLinesWithNoTags === null) {\n      return;\n    }\n\n    const {\n      description,\n      lastDescriptionLine,\n    } = utils.getDescription();\n    if (!(/\\S/v).test(description)) {\n      return;\n    }\n\n    const startingLines = noTags ? startLinesWithNoTags : startLines;\n\n    const trailingLines = description.match(/\\n+$/v)?.[0]?.length;\n    const trailingDiff = (trailingLines ?? 0) - startingLines;\n    if (trailingDiff > 0) {\n      utils.reportJSDoc(\n        `Expected only ${startingLines} line${startingLines === 1 ? '' : 's'} after block description`,\n        {\n          line: lastDescriptionLine - trailingDiff,\n        },\n        () => {\n          utils.setBlockDescription((info, seedTokens, descLines, postDelims) => {\n            return descLines.slice(0, -trailingDiff).map((desc, idx) => {\n              return {\n                number: 0,\n                source: '',\n                tokens: seedTokens({\n                  ...info,\n                  description: desc,\n                  postDelimiter: postDelims[idx],\n                }),\n              };\n            });\n          });\n        },\n      );\n    } else if (trailingDiff < 0) {\n      utils.reportJSDoc(\n        `Expected ${startingLines} lines after block description`,\n        {\n          line: lastDescriptionLine,\n        },\n        () => {\n          utils.setBlockDescription((info, seedTokens, descLines, postDelims) => {\n            return [\n              ...descLines,\n              ...Array.from({\n                length: -trailingDiff,\n              }, () => {\n                return '';\n              }),\n            ].map((desc, idx) => {\n              return {\n                number: 0,\n                source: '',\n                tokens: seedTokens({\n                  ...info,\n                  description: desc,\n                  postDelimiter: desc.trim() ? postDelims[idx] : '',\n                }),\n              };\n            });\n          });\n        },\n      );\n    }\n  }\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    docs: {\n      description: 'Enforces lines (or no lines) before, after, or between tags.',\n      url: 'https://github.com/gajus/eslint-plugin-jsdoc/blob/main/docs/rules/tag-lines.md#repos-sticky-header',\n    },\n    fixable: 'code',\n    schema: [\n      {\n        description: `Defaults to \"never\". \"any\" is only useful with \\`tags\\` (allowing non-enforcement of lines except\nfor particular tags) or with \\`startLines\\`, \\`startLinesWithNoTags\\` \\`endLines\\`, or \\`maxBlockLines\\`. It is also\nnecessary if using the linebreak-setting options of the \\`sort-tags\\` rule\nso that the two rules won't conflict in both attempting to set lines\nbetween tags.`,\n        enum: [\n          'always', 'any', 'never',\n        ],\n        type: 'string',\n      },\n      {\n        additionalProperties: false,\n        properties: {\n          applyToEndTag: {\n            description: `Set to \\`false\\` and use with \"always\" to indicate the normal lines to be\nadded after tags should not be added after the final tag.\n\nDefaults to \\`true\\`.`,\n            type: 'boolean',\n          },\n          count: {\n            description: `Use with \"always\" to indicate the number of lines to require be present.\n\nDefaults to 1.`,\n            type: 'integer',\n          },\n          endLines: {\n            anyOf: [\n              {\n                type: 'integer',\n              },\n              {\n                type: 'null',\n              },\n            ],\n            description: `If not set to \\`null\\`, will enforce end lines to the given count on the\nfinal tag only.\n\nDefaults to \\`0\\`.`,\n          },\n          maxBlockLines: {\n            anyOf: [\n              {\n                type: 'integer',\n              },\n              {\n                type: 'null',\n              },\n            ],\n            description: `If not set to \\`null\\`, will enforce a maximum number of lines to the given count anywhere in the block description.\n\nNote that if non-\\`null\\`, \\`maxBlockLines\\` must be greater than or equal to \\`startLines\\`.\n\nDefaults to \\`null\\`.`,\n          },\n          startLines: {\n            anyOf: [\n              {\n                type: 'integer',\n              },\n              {\n                type: 'null',\n              },\n            ],\n            description: `If not set to \\`null\\`, will enforce end lines to the given count before the\nfirst tag only, unless there is only whitespace content, in which case,\na line count will not be enforced.\n\nDefaults to \\`0\\`.`,\n          },\n          startLinesWithNoTags: {\n            description: 'If set to a number, will enforce a starting lines count when there are no tags. Defaults to `undefined`.',\n            type: 'number',\n          },\n          tags: {\n            description: `Overrides the default behavior depending on specific tags.\n\nAn object whose keys are tag names and whose values are objects with the\nfollowing keys:\n\n1. \\`lines\\` - Set to \\`always\\`, \\`never\\`, or \\`any\\` to override.\n2. \\`count\\` - Overrides main \\`count\\` (for \"always\")\n\nDefaults to empty object.`,\n            patternProperties: {\n              '.*': {\n                additionalProperties: false,\n                properties: {\n                  count: {\n                    type: 'integer',\n                  },\n                  lines: {\n                    enum: [\n                      'always', 'never', 'any',\n                    ],\n                    type: 'string',\n                  },\n                },\n              },\n            },\n            type: 'object',\n          },\n        },\n        type: 'object',\n      },\n    ],\n    type: 'suggestion',\n  },\n});\n"],"mappings":"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","ignoreList":[]}